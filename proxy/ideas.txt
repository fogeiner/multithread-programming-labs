lifecycle:
StartServerTask -> SelectTask

AcceptClient (new socket) -> RecvRequestTask (receiving either until \r\n\r\n or S seconds timeout) -> ParseRequestTask (Parsing received header for info)) -> ProcessRequestTask (if no restrictions applied, try to get a needed CacheEntry; if doesn't exists -- create) -> {if one exists add to waiting users list} {if no exists create new and add to waiting users list}

InitServerConection -> SendRequest -> RecvHeaderTask -> ParseHeaderTask -> {recv to cache if answer is good and the result needs caching} RecvServerData {if the result cannot be cached -- retranslator}

if during another RecvServerData CacheEntry size exceeds maximum -- make retranslator for every client and delete CacheEntry.

SendClientTask

BadRequestTask

Two variants of work: as CachingServer (200 reply)  and as retranslator

retranslator is used always except for 200 reply and less than N Mb data

Caching server mode:
Retranslator mode:

Mode can be switched from cache to just a retraslator;

Retranslator: buffer, c_sock, s_sock; 
Cache: buffer, s_sock and many clients;
Not finished CacheEntry with 0 clients gets dropped
in case of errors:
a) bad request from client: BadRequestTask
b) client closes connection: drop CacheEntry

Retransalor can work with once opened sockets and given buffer

Множество клиентов содержится в списках
	клиенты до анализа запроса включительно
	клиенты, которым передача идет из кеша
	клиенты, которым передача идет напрямую

Множество серверов содержится в списках
	сервер до отправки запроса
	сервер, от которого передача идет в кеш
	сервер, от которого передача идет напрямую

В ProcessRequestTask идет просмотр кеша на предмет наличия записи
Если запись есть и готова, то передача из кеша
Если запись есть и не готова, то добавиться в очередь на отправку
Если записи нет, то создать запись

Проходим по кешу и собираем проинициализированные записи и инициализируем серверные подключения.
